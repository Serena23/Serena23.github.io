{"name":"Serena23.github.io","tagline":"Serena Sforza 426816 - CG Final Project","body":"#Michele De Lucchi\r\n\r\n![MDL photo](http://i40.tinypic.com/2hrk2g8.jpg)\r\n\r\n##Biography\r\nMichele De Lucchi was born in 1951 in Ferrara and graduated in architecture in Florence. \r\nDuring the period of radical and experimental architecture he was a prominent figure in movements like Cavart, Alchymia and Memphis. De Lucchi has designed furniture for the most known Italian and European companies. \r\nFor Olivetti he has been Director of Design from 1992 to 2002 and he developed experimental projects for Compaq Computers, Philips, Siemens and Vitra. \r\n \r\nHe designed and restored buildings in Japan, Germany, Switzerland and in Italy for Enel, Olivetti, Piaggio, Poste Italiane, Telecom Italia. \r\nIn 1999 he was appointed to renovate some of ENEL's (Italys principal Electricity Company) power plants. For Deutsche Bank, Deutsche Bundesbahn, Enel, Poste Italine, Telecom Italia, Hera, Intesa Sanpaolo and other Italian and foreign banks he has redesigned the service environments and corporate image, introducing technical and aesthetic innovation into organization of their working environments. \r\nHe designed buildings for museums including the Triennale di Milano, Palazzo delle Esposizioni di Roma, Neues Museum Berlin and the le Gallerie d'Italia Piazza Scala in Milan. In the last years he developed many architectural projects for private and public client in Georgia, that include the Ministry of Internal Affairs and the bridge of Peace in Tbilisi, the Radison Hotel and Public Service Building in Batumi. \r\n \r\nHis professional work has always gone side-by-side with a personal exploration of architecture, design, technology and crafts. \r\nIn 1990 he founded Produzione Privata, a small-scale production and retail company through which Michele De Lucchi designed products that are made using dedicated artisans and craft techniques. From 2004 he has been using a chain saw to sculpt small wooden houses which create the essentiality of his architectural style. In 2003 the Centre Georges Pompidou in Paris has acquired a considerable number of his works. Selections of his products are exhibited in the most important design Museums in Europe, United States and Japan.\r\n\r\n##My project\r\nFor my final project I have chosen the following works by the architect Michele De Lucchi:\r\n\r\n* Murano glass vases from the private collection\r\n* Estense library\r\n* Firstchair\r\n* Flamingo table\r\n* Kristall table\r\n* Polar coffee table\r\n* Gloria lamp\r\n\r\nI realized my project in two versions using two different programming languages​​: \r\n\r\n* Javascript --> Plasm.js \r\n* Python --> pyplasm\r\n\r\n###Murano glass vases\r\nPrivate collection of vases for flowers made ​​of Murano glass and limited edition products.\r\n\r\n####Realization\r\nThe realization of this work is based mainly on two funcions:\r\n\r\n* **SURFACE**: this funtion draws a surface using ROTATIONAL_SURFACE that is a function of the language Plasm.js\r\n    \r\n        var SURFACE = function (p){\r\n\t    \tvar points = p;\r\n\t    \tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t    \tvar c = BEZIER(S0)(points);\r\n\t\t\tvar surface = MAP(ROTATIONAL_SURFACE(c))(rot_domain);\r\n\t\t\treturn surface;\r\n\t\t}; \t\r\n\tThe parameter p represent an array of points that describe the Bezier curve which will be rotated to create the surface of interest.\r\n* **CYLINDER**: this funtion draws a cylinder using BEZIER CURVES and ROTATIONAL_SURFACE\r\n\r\n\t\tfunction CYLINDER(r,h){\r\n\t\t\tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t\t\tvar p1 = [[0,0,0],[r,0,0]];\r\n\t\t\tvar p2 = [[r,0,0],[r,0,h]];\r\n\t\t\tvar p3 = [[r,0,h],[0,0,h]];\r\n\t\t\tvar c1 = BEZIER(S0)(p1);\r\n\t\t\tvar c2 = BEZIER(S0)(p2);\r\n\t\t\tvar c3 = BEZIER(S0)(p3);\r\n\t\t\tvar s1 = MAP(ROTATIONAL_SURFACE(c1))(rot_domain);\r\n\t\t\tvar s2 = MAP(ROTATIONAL_SURFACE(c2))(rot_domain);\r\n\t\t\tvar s3 = MAP(ROTATIONAL_SURFACE(c3))(rot_domain);\r\n\t\t\tvar cylinder = STRUCT([s1,s2,s3]);\r\n\t\t\treturn cylinder;\r\n\t\t};\r\n\tThe parameter r represent radius of the base circle of the cylinder, the parameter h represent the height of the cylinder. Is first created the profile of the cylinder with BEZIER function and then rotated with ROTATIONAL_SURFACE function.\r\n\r\n####Photos and Screenshots\r\n![photo](http://i41.tinypic.com/2upe2vl.jpg)\r\n![screenshot1](http://i39.tinypic.com/audz77.png)\r\n![screenshot2](http://i40.tinypic.com/hvtfv5.png)\r\n\r\n####Links to the code on github\r\n* [Javascript](https://github.com/cvdlab-cg/426816/blob/master/final-project/javascript/vases.js)\r\n* [Python](https://github.com/cvdlab-cg/426816/blob/master/final-project/python/vases.py)\r\n\r\n\r\n###Estense library\r\nThe Estense (or extended) library was designed by De Lucchi in 2009. Made of walnut, the library comes in an addition of just six, each signed and numbered.\r\n\r\n####Realization\r\nThe realization of this work is based mainly on this funcion:\r\n\r\n* **BLOCK**: this function draws a plan of the library\r\n    \r\n        var BLOCK = function (n,comp){\r\n\t\t\tvar base = CUBOID([n,n]);\r\n\t\t\tvar block = COLOR([150*cc,75*cc,0*cc])(STRUCT([base]));\r\n\t\t\tvar line1 = STRUCT([comp]);\r\n\t\t\tfor (var i = 1; i <= n-1; i++) {\r\n\t\t\t\tline1 = STRUCT([line1,T([0])([i])(comp)]);\r\n\t\t\t};\r\n\t\t\tvar line2 = R([0,1])(PI/2)(line1);\r\n\t\t\tblock = COLOR([150*cc,75*cc,0*cc])(STRUCT([block,base,line1,line2,T([0])([n])(line2),T([1])([n])(line1),T([2])([3])(base)]));\r\n\t\t\treturn block;\r\n\t\t};\r\n\tThe parameter n represent the number of times that the component comp is replicated in each side of the block that represent the plan of the library.\r\n\tIn my case the component to be replicated is:\r\n\t![comp](http://i41.tinypic.com/33c6t20.png)\r\n\tcode:\r\n\t\r\n\t\t\tvar c1 = CUBOID([0.3,0.2,3]);\r\n\t\t\tvar c2 = CUBOID([0.4,0.2,0.3]);\r\n\t\t\tvar comp = COLOR([150*cc,75*cc,0*cc])(STRUCT([c1,T([0])([0.7])(c1),T([0])([0.3])(c2),T([0,2])([0.3,2.7])(c2)]));\r\n\tThe plan created by the invocations of the function block is:\r\n\t![comp](http://i42.tinypic.com/6r56d4.png)\r\n\tcode:\r\n\t\r\n\t\tvar block1 = BLOCK(14,comp);\r\n\tUsing the function BLOCK I created the various plans of the library each time changing the parameter n.\t\t\r\n\r\n####Photos and Screenshots\r\n![photo](http://i44.tinypic.com/29au2p2.jpg)\r\n![screenshot1](http://i43.tinypic.com/jkuamg.png)\r\n\r\n####Links to the code on github\r\n* [Javascript](https://github.com/cvdlab-cg/426816/blob/master/final-project/javascript/estense.js)\r\n* [Python](https://github.com/cvdlab-cg/426816/blob/master/final-project/python/estense.py)\r\n\r\n\r\n###Firstchair\r\nThe First Chair was designed for Michele De Lucchi for the Milan-based company Memphis, who caused a stir in the design world in the 1980s. It was designed in 1983 although its quirky design could easily fit in items from the 1960s as it has a similar playfulness.\r\nItalian Designer Michele de Lucchi created an a piece of sculpture with this aesthetic object. Materials, form and color and shape are re-arranged and no longer subordinate themselves to the pesky principles of function. This chair is considered a work of post-modern art.\r\n\r\n####Realization\r\nThe realization of this work is based mainly on three funcions:\r\n\r\n* **SURFACE**: this funtion draws a surface using ROTATIONAL_SURFACE that is a function of the language Plasm.js\r\n    \r\n        var SURFACE = function (p){\r\n\t    \tvar points = p;\r\n\t    \tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t    \tvar c = BEZIER(S0)(points);\r\n\t\t\tvar surface = MAP(ROTATIONAL_SURFACE(c))(rot_domain);\r\n\t\t\treturn surface;\r\n\t\t}; \t\r\n\tThe parameter p represent an array of points that describe the Bezier curve which will be rotated to create the surface of interest.\r\n* **CYLINDER**: this funtion draws a cylinder using BEZIER CURVES and ROTATIONAL_SURFACE\r\n\r\n\t\tfunction CYLINDER(r,h){\r\n\t\t\tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t\t\tvar p1 = [[0,0,0],[r,0,0]];\r\n\t\t\tvar p2 = [[r,0,0],[r,0,h]];\r\n\t\t\tvar p3 = [[r,0,h],[0,0,h]];\r\n\t\t\tvar c1 = BEZIER(S0)(p1);\r\n\t\t\tvar c2 = BEZIER(S0)(p2);\r\n\t\t\tvar c3 = BEZIER(S0)(p3);\r\n\t\t\tvar s1 = MAP(ROTATIONAL_SURFACE(c1))(rot_domain);\r\n\t\t\tvar s2 = MAP(ROTATIONAL_SURFACE(c2))(rot_domain);\r\n\t\t\tvar s3 = MAP(ROTATIONAL_SURFACE(c3))(rot_domain);\r\n\t\t\tvar cylinder = STRUCT([s1,s2,s3]);\r\n\t\t\treturn cylinder;\r\n\t\t};\r\n\tThe parameter r represent radius of the base circle of the cylinder, the parameter h represent the height of the cylinder. Is first created the profile of the cylinder with BEZIER function and then rotated with ROTATIONAL_SURFACE function.\r\n* **SPHERE**: this funtion draws a sphere using BEZIER CURVES and ROTATIONAL_SURFACE\r\n\r\n\t\tvar SPHERE = function (r){\r\n\t\t\tvar scalefactor = 1.36;\r\n\t\t\tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t\t\tvar p0 = [[0,0,0],[r*scalefactor,0,0],[r*scalefactor,0,r*2],[0,0,r*2]];\r\n\t\t\tvar c0 = BEZIER(S0)(p0);\r\n\t\t\tvar sphere = MAP(ROTATIONAL_SURFACE(c0))(rot_domain);\r\n\t\t\treturn sphere;\r\n\t\t};\r\n\tThe parameter r represent radius of the circle that is rotated to create a sphere.\r\n\r\n####Photos and Screenshots\r\n![photo](http://i39.tinypic.com/30tnbxt.jpg)\r\n![screenshot1](http://i40.tinypic.com/2lbi1d5.png)\r\n\r\n####Links to the code on github\r\n* [Javascript](https://github.com/cvdlab-cg/426816/blob/master/final-project/javascript/firstchair.js)\r\n* [Python](https://github.com/cvdlab-cg/426816/blob/master/final-project/python/firstchair.py)\r\n\r\n\r\n###Flamingo table\r\nFlamingo side table designed in 1984 for Memphis, in laminated wood and plastic.\r\n\r\n####Realization\r\nFor some part of the table I've used this funcion:\r\n\r\n* **CYLINDER**: this funtion draws a cylinder using BEZIER CURVES and ROTATIONAL_SURFACE\r\n\r\n\t\tfunction CYLINDER(r,h){\r\n\t\t\tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t\t\tvar p1 = [[0,0,0],[r,0,0]];\r\n\t\t\tvar p2 = [[r,0,0],[r,0,h]];\r\n\t\t\tvar p3 = [[r,0,h],[0,0,h]];\r\n\t\t\tvar c1 = BEZIER(S0)(p1);\r\n\t\t\tvar c2 = BEZIER(S0)(p2);\r\n\t\t\tvar c3 = BEZIER(S0)(p3);\r\n\t\t\tvar s1 = MAP(ROTATIONAL_SURFACE(c1))(rot_domain);\r\n\t\t\tvar s2 = MAP(ROTATIONAL_SURFACE(c2))(rot_domain);\r\n\t\t\tvar s3 = MAP(ROTATIONAL_SURFACE(c3))(rot_domain);\r\n\t\t\tvar cylinder = STRUCT([s1,s2,s3]);\r\n\t\t\treturn cylinder;\r\n\t\t};\r\n\tThe parameter r represent radius of the base circle of the cylinder, the parameter h represent the height of the cylinder. Is first created the profile of the cylinder with BEZIER function and then rotated with ROTATIONAL_SURFACE function.\r\n\r\nInstead, for the central part of the table, which has oblique stripes, I used two times the function SIMPLICIAL_COMPLEX first creating the black lines and then the white ones. I then joined the two sides into a STRUCT and so I got the texture.\r\n\r\n![texture](http://i42.tinypic.com/9pqhd1.png)\r\ncode:\r\n\r\n\t\tvar points = [/*prima fila*/[0,0,0],[0.1,0,0],[0.2,0,0],[0.3,0,0],[0.4,0,0],[0.5,0,0],\r\n\t[0.6,0,0],[0.7,0,0],[0.8,0,0],[0.9,0,0],[1,0,0],[1.1,0,0],[1.2,0,0],\r\n\t[1.3,0,0],[1.4,0,0],[1.5,0,0],[1.6,0,0],[1.7,0,0],\r\n\t/*seconda fila*/[1.3,0,5],[1.4,0,5],[1.5,0,5],[1.6,0,5],[1.7,0,5],\r\n\t[1.8,0,5],[1.9,0,5],[2,0,5],[2.1,0,5],[2.2,0,5],[2.3,0,5],[2.4,0,5],\r\n\t[2.5,0,5],[2.6,0,5],[2.7,0,5],[2.8,0,5],[2.9,0,5],[3,0,5]];\r\n\r\n\t\tvar cells1 = [[1,19,2],[2,19,20],[3,21,4],[4,21,22],[5,23,6],[6,23,24],\r\n\t[7,25,8],[8,25,26],[9,27,10],[10,27,28],[11,29,12],[12,29,30],[13,31,14],\r\n\t[14,31,32],[15,33,16],[16,33,34]];\r\n\r\n\t\tvar surf1 = COLOR([0,0,0])(SIMPLICIAL_COMPLEX(points)(cells1));\r\n\r\n\t\tvar cells2 = [[0,1,18],[1,18,19],[2,20,3],[3,20,21],[4,22,5],[5,22,23],\r\n\t[6,24,7],[7,24,25],[8,26,9],[9,26,27],[10,28,11],[11,28,29],\r\n\t[12,30,13],[13,30,31],[14,32,15],[15,32,33],[16,34,17],[17,34,35]];\r\n\r\n\t\tvar surf2 = COLOR([255,255,255])(SIMPLICIAL_COMPLEX(points)(cells2));\r\n\r\n\t\tvar points2 = [/*prima fila*/[0,0.3,0],[0,0.2,0],[0,0.1,0],[0,0,0],\r\n\t/*seconda fila*/[1.3,0.3,5],[1.3,0.2,5],[1.3,0.1,5],[1.3,0,5]];\r\n\r\n\t\tvar cells3 = [[0,1,4],[1,4,5],[2,6,3],[3,6,7]];\r\n\r\n\t\tvar surf3 = COLOR([0,0,0])(SIMPLICIAL_COMPLEX(points2)(cells3));\r\n\r\n\t\tvar cells4 = [[1,5,2],[2,5,6]];\r\n\r\n\t\tvar surf4 = COLOR([255,255,255])(SIMPLICIAL_COMPLEX(points2)(cells4));\r\n\r\n\r\n####Photos and Screenshots\r\n![photo1](http://i42.tinypic.com/2rysqwl.jpg)\r\n![screenshot1](http://i42.tinypic.com/t6urs6.png)\r\n![photo2](http://i43.tinypic.com/2mgw9zl.jpg)\r\n![screenshot2](http://i42.tinypic.com/im7xvs.png)\r\n![photo3](http://i43.tinypic.com/k4i2vp.jpg)\r\n![screenshot3](http://i44.tinypic.com/15x4uh5.png)\r\n\r\n####Links to the code on github\r\n* [Javascript](https://github.com/cvdlab-cg/426816/blob/master/final-project/javascript/flamingo.js)\r\n* [Python](https://github.com/cvdlab-cg/426816/blob/master/final-project/python/flamingo.py)\r\n\r\n\r\n###Kristall table\r\nKristall End Table designed in 1981 for Memphis, in plastic laminate, lacquered wood and metal.\r\n\r\n####Realization\r\nFor some part of the table I've used this funcion:\r\n\r\n* **CYLINDER**: this funtion draws a cylinder using BEZIER CURVES and ROTATIONAL_SURFACE\r\n\r\n\t\tfunction CYLINDER(r,h){\r\n\t\t\tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t\t\tvar p1 = [[0,0,0],[r,0,0]];\r\n\t\t\tvar p2 = [[r,0,0],[r,0,h]];\r\n\t\t\tvar p3 = [[r,0,h],[0,0,h]];\r\n\t\t\tvar c1 = BEZIER(S0)(p1);\r\n\t\t\tvar c2 = BEZIER(S0)(p2);\r\n\t\t\tvar c3 = BEZIER(S0)(p3);\r\n\t\t\tvar s1 = MAP(ROTATIONAL_SURFACE(c1))(rot_domain);\r\n\t\t\tvar s2 = MAP(ROTATIONAL_SURFACE(c2))(rot_domain);\r\n\t\t\tvar s3 = MAP(ROTATIONAL_SURFACE(c3))(rot_domain);\r\n\t\t\tvar cylinder = STRUCT([s1,s2,s3]);\r\n\t\t\treturn cylinder;\r\n\t\t};\r\n\tThe parameter r represent radius of the base circle of the cylinder, the parameter h represent the height of the cylinder. Is first created the profile of the cylinder with BEZIER function and then rotated with ROTATIONAL_SURFACE function.\r\n\r\nInstead, for the central part of the table, which has oblique stripes, I used two times the function SIMPLICIAL_COMPLEX first creating the black lines and then the white ones. I then joined the two sides into a STRUCT and so I got the texture.\r\n\r\n![texture](http://i39.tinypic.com/i5xkqv.png)\r\ncode:\r\n\r\n\t\tvar points1 = [/*prima fila*/[0,0,0],[0.5,0,0],[1,0,0],[1.5,0,0],[2,0,0],[2.5,0,0],\r\n\t[3,0,0],[3.5,0,0],[4,0,0],[4.5,0,0],[5,0,0],\r\n\t/*seconda fila*/[0,0.5,0],[5,0.5,0],\r\n\t/*terza fila*/[0,1,0],[5,1,0],\r\n\t/*quarta fila*/[0,1.5,0],[5,1.5,0],\r\n\t/*quinta fila*/[0,2,0],[5,2,0],\r\n\t/*sesta fila*/[0,2.5,0],[5,2.5,0],\r\n\t/*settima fila*/[0,3,0],[5,3,0],\r\n\t/*ottava fila*/[0,3.5,0],[5,3.5,0],\r\n\t/*nona fila*/[0,4,0],[5,4,0],\r\n\t/*decima fila*/[0,4.5,0],[5,4.5,0],\r\n\t/*undicesima fila*/[0,5,0],[5,5,0],\r\n\t/*dodicesima fila*/[0,5.5,0],[5,5.5,0],\r\n\t/*tredicesima fila*/[0,6,0],[5,6,0],\r\n\t/*quattordicesima fila*/[0,6.5,0],[5,6.5,0],\r\n\t/*quindicesima fila*/[0,7,0],[5,7,0],\r\n\t/*sedicesima fila*/[0,7.5,0],[0.5,7.5,0],[1,7.5,0],[1.5,7.5,0],[2,7.5,0],[2.5,7.5,0],\r\n\t[3,7.5,0],[3.5,7.5,0],[4,7.5,0],[4.5,7.5,0],[5,7.5,0]];\r\n\r\n\tvar points2 = [/*prima fila*/[0,0,0],[0.5,0,0],[1,0,0],[1.5,0,0],[2,0,0],[2.5,0,0],\r\n\t[3,0,0],[3.5,0,0],[4,0,0],[4.5,0,0],[5,0,0],\r\n\t/*seconda fila*/[0,0.5,0],[5,0.5,0],\r\n\t/*terza fila*/[0,1,0],[5,1,0],\r\n\t/*quarta fila*/[0,1.5,0],[5,1.5,0],\r\n\t/*quinta fila*/[0,2,0],[5,2,0],\r\n\t/*sesta fila*/[0,2.5,0],[5,2.5,0],\r\n\t/*settima fila*/[0,3,0],[5,3,0],\r\n\t/*ottava fila*/[0,3.5,0],[5,3.5,0],\r\n\t/*nona fila*/[0,4,0],[5,4,0],\r\n\t/*decima fila*/[0,4.5,0],[5,4.5,0],\r\n\t/*undicesima fila*/[0,5,0],[0.5,5,0],[1,5,0],[1.5,5,0],[2,5,0],[2.5,5,0],\r\n\t[3,5,0],[3.5,5,0],[4,5,0],[4.5,5,0],[5,5,0]];\r\n\r\n\tvar cells1 = [[1,11,13],[1,13,2],[3,15,17],[3,17,4],[5,19,21],[5,21,6],[7,23,25],[7,25,8],\r\n\t[9,27,29],[9,29,10],[12,31,33],[12,33,14],[16,35,37],[16,37,18],\r\n\t[20,39,40],[20,40,22],[24,41,42],[24,42,26],[28,43,44],[28,44,30],[32,45,46],\r\n\t[32,46,34],[36,47,48],[36,48,38]];\r\n\tvar s1 = COLOR([0,0,0])(SIMPLICIAL_COMPLEX(points1)(cells1));\r\n\tvar cells2 = [[0,1,11],[2,13,15],[2,15,3],[4,17,19],[4,19,5],[6,21,23],[6,23,7],\r\n\t[8,25,27],[8,27,9],[10,29,31],[10,31,12],[14,33,35],[14,35,16],[18,37,39],\r\n\t[18,39,20],[22,40,41],[22,41,24],[26,42,43],[26,43,28],[30,44,45],[30,45,32],\r\n\t[34,46,47],[34,47,36],[38,48,49]];\r\n\tvar s2 = COLOR([255,255,255])(SIMPLICIAL_COMPLEX(points1)(cells2));\r\n\r\n\tvar cells3 = [[1,11,13],[1,13,2],[3,15,17],[3,17,4],[5,19,21],[5,21,6],[7,23,25],[7,25,8],\r\n\t[9,27,29],[9,29,10],[12,30,31],[12,31,14],[16,32,33],[16,33,18],[20,34,35],[20,35,22],\r\n\t[24,36,37],[24,37,26],[28,38,39]];\r\n\tvar s3 = COLOR([0,0,0])(SIMPLICIAL_COMPLEX(points2)(cells3));\r\n\tvar cells4 = [[0,1,11],[2,13,15],[2,15,3],[4,17,19],[4,19,5],[6,21,23],[6,23,7],\r\n\t[8,25,27],[8,27,9],[10,29,30],[10,30,12],[14,31,32],[14,32,16],[18,33,34],[18,34,20],\r\n\t[22,35,36],[22,36,24],[26,37,38],[26,38,28]];\r\n\tvar s4 = COLOR([255,255,255])(SIMPLICIAL_COMPLEX(points2)(cells4));\r\n\r\n\tvar surface1 = STRUCT([s1,s2]);\r\n\tvar surface2 = R([0,2])(-PI/2)(surface1);\r\n\tvar surface3 = T([2])([5])(STRUCT([s1,s2]));\r\n\tvar surface4 = T([0])([5])(surface2);\r\n\tvar surface5 = R([1,2])(PI/2)(STRUCT([s3,s4]));\r\n\tvar surface6 = T([0,1,2])([5,7.5,5])(R([0,1])(PI)(R([1,2])(PI)(surface5)));\r\n\tvar block = STRUCT([surface1,surface2,surface3,surface4,surface5,surface6]);\r\n\r\n\r\n####Photos and Screenshots\r\n![photo1](http://i43.tinypic.com/ao03z6.jpg)\r\n![screenshot1](http://i40.tinypic.com/nv1x83.png)\r\n![photo2](http://i41.tinypic.com/n4fhqo.png)\r\n![screenshot2](http://i42.tinypic.com/35c2xsp.png)\r\n\r\n####Links to the code on github\r\n* [Javascript](https://github.com/cvdlab-cg/426816/blob/master/final-project/javascript/kristall.js)\r\n* [Python](https://github.com/cvdlab-cg/426816/blob/master/final-project/python/kristall.py)\r\n\r\n\r\n###Polar coffee table\r\nPolar coffee table designed by in 1984 for Memphis, in plastic laminate and lacquered.\r\n\r\n####Realization\r\nThe realization of this work is based mainly on two funcions:\r\n\r\n* **BLOCK**: this funtion draws the central part of the table\r\n    \r\n        var BLOCK = function (n){\r\n\t\t\tvar c1 = COLOR([255,255,255])(CUBOID([0.1,0,3]));\r\n\t\t\tvar c2 = COLOR([0,0,0])(CUBOID([0.1,0,3]));\r\n\t\t\tvar block1 = STRUCT([c1]);\r\n\t\t\tvar block2 = STRUCT([T([0])([0.1])(c2)]);\r\n\t\t\tfor (var i = 2; i <= n-1; i++) {\r\n\t\t\tif (i%2==0){\r\n\t\t\t\tblock1 = STRUCT([block1,T([0])([i/10])(c1)]);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tblock2 = STRUCT([block2,T([0])([i/10])(c2)]);\r\n\t\t\t}\r\n\t\t};\r\n\t\tblock = STRUCT([block1,block2]);\r\n\t\treturn block;\r\n\t\t};\r\n\tThe parameter n represent the number of stripes in the central part of the table.\r\n\t\r\n* **CYLINDER**: this funtion draws a cylinder using BEZIER CURVES and ROTATIONAL_SURFACE\r\n\r\n\t\tfunction CYLINDER(r,h){\r\n\t\t\tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t\t\tvar p1 = [[0,0,0],[r,0,0]];\r\n\t\t\tvar p2 = [[r,0,0],[r,0,h]];\r\n\t\t\tvar p3 = [[r,0,h],[0,0,h]];\r\n\t\t\tvar c1 = BEZIER(S0)(p1);\r\n\t\t\tvar c2 = BEZIER(S0)(p2);\r\n\t\t\tvar c3 = BEZIER(S0)(p3);\r\n\t\t\tvar s1 = MAP(ROTATIONAL_SURFACE(c1))(rot_domain);\r\n\t\t\tvar s2 = MAP(ROTATIONAL_SURFACE(c2))(rot_domain);\r\n\t\t\tvar s3 = MAP(ROTATIONAL_SURFACE(c3))(rot_domain);\r\n\t\t\tvar cylinder = STRUCT([s1,s2,s3]);\r\n\t\t\treturn cylinder;\r\n\t\t};\r\n\tThe parameter r represent radius of the base circle of the cylinder, the parameter h represent the height of the cylinder. Is first created the profile of the cylinder with BEZIER function and then rotated with ROTATIONAL_SURFACE function.\r\n\r\n####Photos and Screenshots\r\n![photo1](http://i44.tinypic.com/15ry6x5.jpg)\r\n![screenshot1](http://i43.tinypic.com/4ub385.png)\r\n![photo2](http://i39.tinypic.com/2e0vayr.png)\r\n![screenshot2](http://i41.tinypic.com/205sftk.png)\r\n\r\n####Links to the code on github\r\n* [Javascript](https://github.com/cvdlab-cg/426816/blob/master/final-project/javascript/polar.js)\r\n* [Python](https://github.com/cvdlab-cg/426816/blob/master/final-project/python/polar.py)\r\n\r\n\r\n###Gloria lamp\r\nMichele de Lucchi created this lamp as part of his 'Nature Series'. Michele de Lucchi: 'When lamps fall from the ceiling people always try to protect their eyes from the flash of the bulb and jars of varying shapes and sizes are always made to create romantic and erotic atmospheres. Today however, there are bulbs that do everything by themselves and there is no more need for shades, bells, pans, lids and pots. So not having anywhere left to unload my creativity into except the dangling wire, I decided to decorate it and to unload onto a thin rod all my needs for free expressiveness and uncontrolled imagination. I was very much helped by the sophisticated technology of laser cutting and by the generous performances of botanical and biological science. \r\n\r\n####Realization\r\nThe realization of this work is based mainly on two funcions:\r\n\r\n* **SURFACE**: this funtion draws a surface using ROTATIONAL_SURFACE that is a function of the language Plasm.js\r\n    \r\n        var SURFACE = function (p){\r\n\t    \tvar points = p;\r\n\t    \tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t    \tvar c = BEZIER(S0)(points);\r\n\t\t\tvar surface = MAP(ROTATIONAL_SURFACE(c))(rot_domain);\r\n\t\t\treturn surface;\r\n\t\t}; \t\r\n\tThe parameter p represent an array of points that describe the Bezier curve which will be rotated to create the surface of interest.\r\n* **CYLINDER**: this funtion draws a cylinder using BEZIER CURVES and ROTATIONAL_SURFACE\r\n\r\n\t\tfunction CYLINDER(r,h){\r\n\t\t\tvar rot_domain = DOMAIN([[0,1],[0,2*PI]])([40,40]);\r\n\t\t\tvar p1 = [[0,0,0],[r,0,0]];\r\n\t\t\tvar p2 = [[r,0,0],[r,0,h]];\r\n\t\t\tvar p3 = [[r,0,h],[0,0,h]];\r\n\t\t\tvar c1 = BEZIER(S0)(p1);\r\n\t\t\tvar c2 = BEZIER(S0)(p2);\r\n\t\t\tvar c3 = BEZIER(S0)(p3);\r\n\t\t\tvar s1 = MAP(ROTATIONAL_SURFACE(c1))(rot_domain);\r\n\t\t\tvar s2 = MAP(ROTATIONAL_SURFACE(c2))(rot_domain);\r\n\t\t\tvar s3 = MAP(ROTATIONAL_SURFACE(c3))(rot_domain);\r\n\t\t\tvar cylinder = STRUCT([s1,s2,s3]);\r\n\t\t\treturn cylinder;\r\n\t\t};\r\n\tThe parameter r represent radius of the base circle of the cylinder, the parameter h represent the height of the cylinder. Is first created the profile of the cylinder with BEZIER function and then rotated with ROTATIONAL_SURFACE function.\r\n\t\r\nFor the branches with the leaves, I first created a leaf with some Bezier curves, then I mirrored and I created a couple of leaves that have replicated and scaled up to compose the entire class.\r\n![screenshot](http://i43.tinypic.com/2hr3fok.png)\r\n\r\n####Photos and Screenshots\r\n![photo1](http://i40.tinypic.com/6hi89h.jpg)\r\n![screenshot1](http://i43.tinypic.com/208wvpz.png)\r\n\r\n####Links to the code on github\r\n* [Javascript](https://github.com/cvdlab-cg/426816/blob/master/final-project/javascript/gloria.js)\r\n* [Python](https://github.com/cvdlab-cg/426816/blob/master/final-project/python/gloria.py)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}